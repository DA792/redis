# 🧪 缓存穿透和缓存击穿测试指南

## 📋 测试目标

本测试旨在验证Redis缓存中两个重要问题的解决方案：
1. **缓存穿透** - 查询不存在的数据绕过缓存直击数据库
2. **缓存击穿** - 热点数据过期时的高并发访问

## 🎯 测试场景说明

### 1. 缓存穿透测试 (`testCachePenetration`)

**问题描述：**
- 请求查询一个不存在的数据（如商铺ID: 999999）
- 缓存中没有，数据库中也没有
- 恶意用户可能利用这个特点让请求都打到数据库

**测试方式：**
```java
// 模拟100个并发请求查询不存在的商铺
Long nonExistentId = 999999L;
Shop shop = cacheClient.queryWithPassThrough(...);
```

**解决方案验证：**
- ✅ 第一次查询数据库返回null
- ✅ 将空值("")缓存到Redis，设置较短过期时间
- ✅ 后续相同请求直接从缓存返回null，不再查询数据库

### 2. 缓存击穿测试 (`testCacheBreakdown`)

**问题描述：**
- 热点数据（如热门商铺）的缓存过期
- 同时有大量请求访问这个数据
- 所有请求都会打到数据库，可能造成数据库压力

**测试方式：**
```java
// 1. 预热缓存，设置2秒逻辑过期
cacheClient.setWithLogicalExpire("cache:shop:1", shop, 2L, TimeUnit.SECONDS);

// 2. 等待3秒让缓存逻辑过期

// 3. 模拟200个并发请求访问过期的热点数据
Shop shop = cacheClient.queryWithLogicalExpire(...);
```

**解决方案验证：**
- ✅ 第一个请求获取互斥锁，异步重建缓存
- ✅ 其他请求返回过期数据（不会阻塞）
- ✅ 避免了大量请求同时查询数据库

### 3. 互斥锁测试 (`testMutexLockCacheBreakdown`)

**问题描述：**
- 另一种解决缓存击穿的方案
- 使用互斥锁确保只有一个线程查询数据库

**测试方式：**
```java
// 模拟100个并发请求
Result result = shopService.queryById(shopId);
```

**解决方案验证：**
- ✅ 第一个请求获取锁，查询数据库并重建缓存
- ✅ 其他请求等待锁释放，然后从缓存获取数据
- ✅ 确保数据库只被查询一次

## 🚀 运行测试

### 前置条件
1. ✅ Redis服务运行正常
2. ✅ 数据库连接正常
3. ✅ 数据库中存在ID为1和2的商铺数据

### 执行方式

#### 方式1：IDE中运行
```bash
# 在IDEA中右键测试方法 -> Run
testCachePenetration()      # 测试缓存穿透
testCacheBreakdown()        # 测试缓存击穿(逻辑过期)
testMutexLockCacheBreakdown() # 测试缓存击穿(互斥锁)
```

#### 方式2：Maven命令行
```bash
# 运行指定测试方法
mvn test -Dtest=HmDianPingApplicationTest#testCachePenetration
mvn test -Dtest=HmDianPingApplicationTest#testCacheBreakdown
mvn test -Dtest=HmDianPingApplicationTest#testMutexLockCacheBreakdown

# 运行所有测试
mvn test -Dtest=HmDianPingApplicationTest
```

## 📊 预期测试结果

### 缓存穿透测试
```
=== 开始测试缓存穿透 ===
查询ID 999999 结果: null
查询ID 999999 结果: null
...
缓存穿透测试完成，耗时: XXXms
=== 缓存穿透测试结束 ===
```

### 缓存击穿测试
```
=== 开始测试缓存击穿 ===
预热缓存完成，等待3秒让缓存逻辑过期...
线程0查询结果: 商铺名: 102茶餐厅
线程1查询结果: 商铺名: 102茶餐厅
...
缓存击穿测试完成，耗时: XXXms
=== 缓存击穿测试结束 ===
```

## 🔍 观察要点

### 1. 性能对比
- **无缓存保护**：每次请求都查询数据库，耗时较长
- **有缓存保护**：大部分请求从缓存返回，耗时较短

### 2. Redis监控
```bash
# 在Redis客户端监控命令执行
redis-cli monitor

# 观察关键操作
- GET cache:shop:999999  # 缓存穿透查询
- SET cache:shop:999999 ""  # 空值缓存
- GET cache:shop:1       # 热点数据查询
- SETIFABSENT lock:shop:1  # 互斥锁操作
```

### 3. 数据库监控
- 观察SQL执行次数
- 缓存穿透：第一次查询后不再执行SQL
- 缓存击穿：只有一个线程执行SQL重建缓存

## 🛠️ 故障排查

### 常见问题
1. **Redis连接失败**
   - 检查 `application.yaml` 中Redis配置
   - 确认Redis服务状态

2. **数据库查询失败**
   - 确认数据库中存在测试数据
   - 检查数据库连接配置

3. **测试超时**
   - 适当调整线程池大小和并发数量
   - 检查网络延迟

### 调试建议
```java
// 添加更多日志输出
System.out.println("线程" + threadNum + "开始执行");
System.out.println("缓存查询结果: " + cacheResult);
System.out.println("数据库查询结果: " + dbResult);
```

## 📈 扩展测试

### 1. 压力测试
- 增加并发线程数量 (500+)
- 增加请求总数 (1000+)
- 测试系统极限情况

### 2. 缓存雪崩测试
```java
// 模拟大量缓存同时过期
for(int i = 1; i <= 100; i++) {
    cacheClient.setWithLogicalExpire("cache:shop:" + i, 
        shop, 1L, TimeUnit.SECONDS);
}
```

### 3. 布隆过滤器测试
```java
// 可以添加布隆过滤器来更好地解决缓存穿透
BloomFilter<Long> bloomFilter = BloomFilter.create(...);
```

---

📝 **测试完成后记得清理Redis缓存和检查数据一致性！** 